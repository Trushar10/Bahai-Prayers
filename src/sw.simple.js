import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import {
	CacheFirst,
	NetworkFirst,
	StaleWhileRevalidate,
} from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';

// Cache version - update this to force cache refresh
const CACHE_VERSION = 'v2';

// Precache files generated by Next.js build
precacheAndRoute(self.__WB_MANIFEST || []);

// Clean up outdated caches
cleanupOutdatedCaches();

// Cache the main app shell and prayer pages with offline-first approach
registerRoute(
	({ request, url }) => {
		return (
			request.mode === 'navigate' &&
			(url.pathname === '/' ||
				url.pathname === '/index' ||
				url.pathname === '/offline' ||
				// Match prayer page routes (any path that doesn't start with /api/ or special paths)
				(!url.pathname.startsWith('/api/') &&
					!url.pathname.startsWith('/_next/') &&
					!url.pathname.startsWith('/static/') &&
					!url.pathname.endsWith('.js') &&
					!url.pathname.endsWith('.css') &&
					!url.pathname.endsWith('.json') &&
					!url.pathname.endsWith('.ico')))
		);
	},
	new NetworkFirst({
		cacheName: `pages-cache-${CACHE_VERSION}`,
		plugins: [
			new CacheableResponsePlugin({
				statuses: [0, 200],
			}),
			new ExpirationPlugin({
				maxEntries: 100,
				maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
			}),
		],
		networkTimeoutSeconds: 3, // Fallback to cache after 3 seconds
	})
);

// Cache API calls with offline-first approach
registerRoute(
	({ url }) => url.pathname.startsWith('/api/prayers'),
	new CacheFirst({
		cacheName: 'prayers-api-cache',
		plugins: [
			new CacheableResponsePlugin({
				statuses: [0, 200],
			}),
			new ExpirationPlugin({
				maxEntries: 100,
				maxAgeSeconds: 60 * 60 * 24 * 90, // 90 days
			}),
		],
	})
);

// Cache individual prayer API calls
registerRoute(
	({ url }) => url.pathname.startsWith('/api/prayer/'),
	new CacheFirst({
		cacheName: 'prayer-details-cache',
		plugins: [
			new CacheableResponsePlugin({
				statuses: [0, 200],
			}),
			new ExpirationPlugin({
				maxEntries: 500,
				maxAgeSeconds: 60 * 60 * 24 * 90, // 90 days
			}),
		],
	})
);

// Cache static assets (JS, CSS, images)
registerRoute(
	({ request }) =>
		request.destination === 'script' ||
		request.destination === 'style' ||
		request.destination === 'image' ||
		request.destination === 'font',
	new StaleWhileRevalidate({
		cacheName: 'static-resources',
		plugins: [
			new CacheableResponsePlugin({
				statuses: [0, 200],
			}),
			new ExpirationPlugin({
				maxEntries: 200,
				maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
			}),
		],
	})
);

// Handle offline navigation - serve cached page or offline page
registerRoute(
	new NavigationRoute(
		new NetworkFirst({
			cacheName: 'navigation-cache',
			plugins: [
				new CacheableResponsePlugin({
					statuses: [0, 200],
				}),
			],
			networkTimeoutSeconds: 3,
		})
	)
);

// Install event - cache essential resources immediately
self.addEventListener('install', (event) => {
	console.log('Service Worker installing...');

	// Cache essential pages immediately and aggressively
	event.waitUntil(
		Promise.all([
			// Cache in essential cache
			caches.open(`essential-cache-${CACHE_VERSION}`).then((cache) => {
				return cache
					.addAll(['/', '/offline', '/manifest.json'])
					.catch((error) => {
						console.warn(
							'Failed to cache essential resources:',
							error
						);
					});
			}),
			// Also cache in pages cache for better lookup
			caches.open(`pages-cache-${CACHE_VERSION}`).then((cache) => {
				return cache.addAll(['/', '/offline']).catch((error) => {
					console.warn('Failed to cache pages:', error);
				});
			}),
		])
	);

	// Force immediate activation
	self.skipWaiting();
});

// Activate event - take control immediately and clean old caches
self.addEventListener('activate', (event) => {
	console.log('Service Worker activating...');
	event.waitUntil(
		Promise.all([
			self.clients.claim(),
			// Clean up old caches
			caches.keys().then((cacheNames) => {
				return Promise.all(
					cacheNames.map((cacheName) => {
						// Delete old versions of our caches
						if (
							cacheName.includes('pages-cache') &&
							!cacheName.includes(CACHE_VERSION)
						) {
							console.log('Deleting old cache:', cacheName);
							return caches.delete(cacheName);
						}
						if (
							cacheName.includes('essential-cache') &&
							!cacheName.includes(CACHE_VERSION)
						) {
							console.log('Deleting old cache:', cacheName);
							return caches.delete(cacheName);
						}
						return null;
					})
				);
			}),
		])
	);
});

// Handle fetch events for better offline support
self.addEventListener('fetch', (event) => {
	// Handle navigation requests specially
	if (event.request.mode === 'navigate') {
		event.respondWith(
			// Try network first with short timeout
			Promise.race([
				fetch(event.request),
				new Promise((_, reject) =>
					setTimeout(() => reject(new Error('Network timeout')), 1000)
				),
			])
				.then((response) => {
					// If online and successful, cache the response
					if (response.ok) {
						const responseClone = response.clone();
						Promise.all([
							caches
								.open(`pages-cache-${CACHE_VERSION}`)
								.then((cache) => {
									cache.put(
										event.request,
										responseClone.clone()
									);
								}),
							caches
								.open(`essential-cache-${CACHE_VERSION}`)
								.then((cache) => {
									if (
										event.request.url.endsWith('/') ||
										event.request.url.includes(
											'localhost:3000'
										)
									) {
										cache.put(
											event.request,
											responseClone.clone()
										);
									}
								}),
						]);
					}
					return response;
				})
				.catch(async () => {
					console.log(
						'Offline - serving from cache for:',
						event.request.url
					);

					// Try multiple cache strategies when offline
					// 1. Try exact URL match in pages cache
					let cachedResponse = await caches.match(event.request);
					if (cachedResponse) {
						console.log('Found exact match in cache');
						return cachedResponse;
					}

					// 2. Try pathname match in pages cache
					const url = new URL(event.request.url);
					const pathname = url.pathname;

					const pagesCache = await caches.open(
						`pages-cache-${CACHE_VERSION}`
					);
					cachedResponse = await pagesCache.match(pathname);
					if (cachedResponse) {
						console.log('Found pathname match in pages cache');
						return cachedResponse;
					}

					// 3. Try essential cache
					const essentialCache = await caches.open(
						`essential-cache-${CACHE_VERSION}`
					);
					cachedResponse = await essentialCache.match('/');
					if (cachedResponse) {
						console.log('Serving home page from essential cache');
						return cachedResponse;
					}

					// 4. Try any available home page
					cachedResponse = await caches.match('/');
					if (cachedResponse) {
						console.log('Found home page in any cache');
						return cachedResponse;
					}

					// 5. Try offline page
					cachedResponse = await caches.match('/offline');
					if (cachedResponse) {
						console.log('Serving offline page');
						return cachedResponse;
					}

					// 6. Last resort - inline offline response
					console.log('Serving inline offline response');
					return new Response(
						`<!DOCTYPE html>
            <html>
              <head>
                <title>Offline - Prayer App</title>
                <meta name="viewport" content="width=device-width, initial-scale=1">
                <meta name="theme-color" content="#317EFB">
                <style>
                  body { 
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
                    margin: 0; padding: 50px 20px; text-align: center; 
                    background: #f8f9fa; min-height: 100vh;
                    display: flex; align-items: center; justify-content: center;
                  }
                  .offline-container { 
                    background: white; padding: 40px; border-radius: 12px; 
                    box-shadow: 0 4px 20px rgba(0,0,0,0.1); max-width: 400px; 
                  }
                  .offline { color: #666; }
                  .back-btn { 
                    margin: 10px 5px; padding: 12px 20px; 
                    background: #317EFB; color: white; border: none; 
                    border-radius: 8px; cursor: pointer; font-size: 14px;
                    text-decoration: none; display: inline-block;
                  }
                  .back-btn:hover { background: #2563eb; }
                  h1 { color: #317EFB; margin-bottom: 20px; }
                </style>
              </head>
              <body>
                <div class="offline-container">
                  <div class="offline">
                    <h1>üì± Prayer App</h1>
                    <p><strong>You're currently offline</strong></p>
                    <p>This content isn't available offline yet.</p>
                    <p>Please connect to the internet or try:</p>
                    <button class="back-btn" onclick="window.history.back()">‚Üê Go Back</button>
                    <button class="back-btn" onclick="window.location.href='/'">üè† Home</button>
                    <br><br>
                    <button class="back-btn" onclick="window.location.reload()" style="background:#6c757d">üîÑ Retry</button>
                  </div>
                </div>
              </body>
            </html>`,
						{
							headers: { 'Content-Type': 'text/html' },
							status: 200,
						}
					);
				})
		);
	}
});

// Listen for messages from the main thread
self.addEventListener('message', (event) => {
	if (event.data && event.data.type === 'SKIP_WAITING') {
		self.skipWaiting();
	}
});
